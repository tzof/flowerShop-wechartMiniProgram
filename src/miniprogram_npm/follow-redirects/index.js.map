{"version":3,"sources":["index.js","http.js","https.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;AACA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["var url = require(\"url\");\r\nvar http = require(\"http\");\r\nvar https = require(\"https\");\r\nvar assert = require(\"assert\");\r\nvar Writable = require(\"stream\").Writable;\r\nvar debug = require(\"debug\")(\"follow-redirects\");\r\n\r\n// RFC7231§4.2.1: Of the request methods defined by this specification,\r\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\r\nvar SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };\r\n\r\n// Create handlers that pass events from native requests\r\nvar eventHandlers = Object.create(null);\r\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\r\n  eventHandlers[event] = function (arg) {\r\n    this._redirectable.emit(event, arg);\r\n  };\r\n});\r\n\r\n// An HTTP(S) request that can be redirected\r\nfunction RedirectableRequest(options, responseCallback) {\r\n  // Initialize the request\r\n  Writable.call(this);\r\n  options.headers = options.headers || {};\r\n  this._options = options;\r\n  this._redirectCount = 0;\r\n  this._redirects = [];\r\n  this._requestBodyLength = 0;\r\n  this._requestBodyBuffers = [];\r\n\r\n  // Since http.request treats host as an alias of hostname,\r\n  // but the url module interprets host as hostname plus port,\r\n  // eliminate the host property to avoid confusion.\r\n  if (options.host) {\r\n    // Use hostname if set, because it has precedence\r\n    if (!options.hostname) {\r\n      options.hostname = options.host;\r\n    }\r\n    delete options.host;\r\n  }\r\n\r\n  // Attach a callback if passed\r\n  if (responseCallback) {\r\n    this.on(\"response\", responseCallback);\r\n  }\r\n\r\n  // React to responses of native requests\r\n  var self = this;\r\n  this._onNativeResponse = function (response) {\r\n    self._processResponse(response);\r\n  };\r\n\r\n  // Complete the URL object when necessary\r\n  if (!options.pathname && options.path) {\r\n    var searchPos = options.path.indexOf(\"?\");\r\n    if (searchPos < 0) {\r\n      options.pathname = options.path;\r\n    }\r\n    else {\r\n      options.pathname = options.path.substring(0, searchPos);\r\n      options.search = options.path.substring(searchPos);\r\n    }\r\n  }\r\n\r\n  // Perform the first request\r\n  this._performRequest();\r\n}\r\nRedirectableRequest.prototype = Object.create(Writable.prototype);\r\n\r\n// Writes buffered data to the current native request\r\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\r\n  // Validate input and shift parameters if necessary\r\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\r\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\r\n  }\r\n  if (typeof encoding === \"function\") {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Ignore empty buffers, since writing them doesn't invoke the callback\r\n  // https://github.com/nodejs/node/issues/22066\r\n  if (data.length === 0) {\r\n    if (callback) {\r\n      callback();\r\n    }\r\n    return;\r\n  }\r\n  // Only write when we don't exceed the maximum body length\r\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\r\n    this._requestBodyLength += data.length;\r\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\r\n    this._currentRequest.write(data, encoding, callback);\r\n  }\r\n  // Error when we exceed the maximum body length\r\n  else {\r\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\r\n    this.abort();\r\n  }\r\n};\r\n\r\n// Ends the current native request\r\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\r\n  // Shift parameters if necessary\r\n  if (typeof data === \"function\") {\r\n    callback = data;\r\n    data = encoding = null;\r\n  }\r\n  else if (typeof encoding === \"function\") {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Write data and end\r\n  var currentRequest = this._currentRequest;\r\n  this.write(data || \"\", encoding, function () {\r\n    currentRequest.end(null, null, callback);\r\n  });\r\n};\r\n\r\n// Sets a header value on the current native request\r\nRedirectableRequest.prototype.setHeader = function (name, value) {\r\n  this._options.headers[name] = value;\r\n  this._currentRequest.setHeader(name, value);\r\n};\r\n\r\n// Clears a header value on the current native request\r\nRedirectableRequest.prototype.removeHeader = function (name) {\r\n  delete this._options.headers[name];\r\n  this._currentRequest.removeHeader(name);\r\n};\r\n\r\n// Proxy all other public ClientRequest methods\r\n[\r\n  \"abort\", \"flushHeaders\", \"getHeader\",\r\n  \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\",\r\n].forEach(function (method) {\r\n  RedirectableRequest.prototype[method] = function (a, b) {\r\n    return this._currentRequest[method](a, b);\r\n  };\r\n});\r\n\r\n// Proxy all public ClientRequest properties\r\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\r\n  Object.defineProperty(RedirectableRequest.prototype, property, {\r\n    get: function () { return this._currentRequest[property]; },\r\n  });\r\n});\r\n\r\n// Executes the next native request (initial or redirect)\r\nRedirectableRequest.prototype._performRequest = function () {\r\n  // Load the native protocol\r\n  var protocol = this._options.protocol;\r\n  var nativeProtocol = this._options.nativeProtocols[protocol];\r\n  if (!nativeProtocol) {\r\n    this.emit(\"error\", new Error(\"Unsupported protocol \" + protocol));\r\n    return;\r\n  }\r\n\r\n  // If specified, use the agent corresponding to the protocol\r\n  // (HTTP and HTTPS use different types of agents)\r\n  if (this._options.agents) {\r\n    var scheme = protocol.substr(0, protocol.length - 1);\r\n    this._options.agent = this._options.agents[scheme];\r\n  }\r\n\r\n  // Create the native request\r\n  var request = this._currentRequest =\r\n        nativeProtocol.request(this._options, this._onNativeResponse);\r\n  this._currentUrl = url.format(this._options);\r\n\r\n  // Set up event handlers\r\n  request._redirectable = this;\r\n  for (var event in eventHandlers) {\r\n    /* istanbul ignore else */\r\n    if (event) {\r\n      request.on(event, eventHandlers[event]);\r\n    }\r\n  }\r\n\r\n  // End a redirected request\r\n  // (The first request must be ended explicitly with RedirectableRequest#end)\r\n  if (this._isRedirect) {\r\n    // Write the request entity and end.\r\n    var i = 0;\r\n    var buffers = this._requestBodyBuffers;\r\n    (function writeNext() {\r\n      if (i < buffers.length) {\r\n        var buffer = buffers[i++];\r\n        request.write(buffer.data, buffer.encoding, writeNext);\r\n      }\r\n      else {\r\n        request.end();\r\n      }\r\n    }());\r\n  }\r\n};\r\n\r\n// Processes a response from the current native request\r\nRedirectableRequest.prototype._processResponse = function (response) {\r\n  // Store the redirected response\r\n  if (this._options.trackRedirects) {\r\n    this._redirects.push({\r\n      url: this._currentUrl,\r\n      headers: response.headers,\r\n      statusCode: response.statusCode,\r\n    });\r\n  }\r\n\r\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\r\n  // that further action needs to be taken by the user agent in order to\r\n  // fulfill the request. If a Location header field is provided,\r\n  // the user agent MAY automatically redirect its request to the URI\r\n  // referenced by the Location field value,\r\n  // even if the specific status code is not understood.\r\n  var location = response.headers.location;\r\n  if (location && this._options.followRedirects !== false &&\r\n      response.statusCode >= 300 && response.statusCode < 400) {\r\n    // RFC7231§6.4: A client SHOULD detect and intervene\r\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\r\n    if (++this._redirectCount > this._options.maxRedirects) {\r\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\r\n      return;\r\n    }\r\n\r\n    // RFC7231§6.4: Automatic redirection needs to done with\r\n    // care for methods not known to be safe […],\r\n    // since the user might not wish to redirect an unsafe request.\r\n    // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates\r\n    // that the target resource resides temporarily under a different URI\r\n    // and the user agent MUST NOT change the request method\r\n    // if it performs an automatic redirection to that URI.\r\n    var header;\r\n    var headers = this._options.headers;\r\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\r\n      this._options.method = \"GET\";\r\n      // Drop a possible entity and headers related to it\r\n      this._requestBodyBuffers = [];\r\n      for (header in headers) {\r\n        if (/^content-/i.test(header)) {\r\n          delete headers[header];\r\n        }\r\n      }\r\n    }\r\n\r\n    // Drop the Host header, as the redirect might lead to a different host\r\n    if (!this._isRedirect) {\r\n      for (header in headers) {\r\n        if (/^host$/i.test(header)) {\r\n          delete headers[header];\r\n        }\r\n      }\r\n    }\r\n\r\n    // Perform the redirected request\r\n    var redirectUrl = url.resolve(this._currentUrl, location);\r\n    debug(\"redirecting to\", redirectUrl);\r\n    Object.assign(this._options, url.parse(redirectUrl));\r\n    this._isRedirect = true;\r\n    this._performRequest();\r\n\r\n    // Discard the remainder of the response to avoid waiting for data\r\n    response.destroy();\r\n  }\r\n  else {\r\n    // The response is not a redirect; return it as-is\r\n    response.responseUrl = this._currentUrl;\r\n    response.redirects = this._redirects;\r\n    this.emit(\"response\", response);\r\n\r\n    // Clean up\r\n    this._requestBodyBuffers = [];\r\n  }\r\n};\r\n\r\n// Wraps the key/value object of protocols with redirect functionality\r\nfunction wrap(protocols) {\r\n  // Default settings\r\n  var exports = {\r\n    maxRedirects: 21,\r\n    maxBodyLength: 10 * 1024 * 1024,\r\n  };\r\n\r\n  // Wrap each protocol\r\n  var nativeProtocols = {};\r\n  Object.keys(protocols).forEach(function (scheme) {\r\n    var protocol = scheme + \":\";\r\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\r\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\r\n\r\n    // Executes a request, following redirects\r\n    wrappedProtocol.request = function (options, callback) {\r\n      if (typeof options === \"string\") {\r\n        options = url.parse(options);\r\n        options.maxRedirects = exports.maxRedirects;\r\n      }\r\n      else {\r\n        options = Object.assign({\r\n          protocol: protocol,\r\n          maxRedirects: exports.maxRedirects,\r\n          maxBodyLength: exports.maxBodyLength,\r\n        }, options);\r\n      }\r\n      options.nativeProtocols = nativeProtocols;\r\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\r\n      debug(\"options\", options);\r\n      return new RedirectableRequest(options, callback);\r\n    };\r\n\r\n    // Executes a GET request, following redirects\r\n    wrappedProtocol.get = function (options, callback) {\r\n      var request = wrappedProtocol.request(options, callback);\r\n      request.end();\r\n      return request;\r\n    };\r\n  });\r\n  return exports;\r\n}\r\n\r\n// Exports\r\nmodule.exports = wrap({ http: http, https: https });\r\nmodule.exports.wrap = wrap;\r\n","module.exports = require(\"./\").http;\r\n","module.exports = require(\"./\").https;\r\n"]}